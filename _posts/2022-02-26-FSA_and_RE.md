---
title: 词法分析之NFA, DFA, Min-DFA与RE, RG
date: 2022-03-02 23:52
category:
- 编译原理
- 自动机理论
tags:
- 词法分析
- Finite State Automata
---

> Computation with automata.

<!-- more -->

## Glossary

- NFA: Non-Deterministic Finite Automata 非确定性的有限状态自动机
  - 对于NFA的非确定, 有两种有趣的解释
    1. 在需要做出不确定选择的时候, NFA会复制自己并执行所有的操作, 如果最终有任何一台自动机到达了接收状态, 那么NFA接收这个输入
    2. 在需要做出不确定选择的时候, NFA的选择总是正确, 也就是说, 只要这个串是能被接收的, 那NFA一定能选对
- DFA: Deterministic Finite Automata 确定性的有限状态自动机
- Min-DFA: Minimal Deterministic Finite Automata 最小的DFA
- RE: Regular Expression 正则表达式
- RG: Regular Grammar 正则文法

## NFA,DFA,Min-DFA,RE的关系

一般地，认为NFA, DFA, Min-DFA, RE的关系如下


```mermaid
graph LR
A[NFA]
B[DFA]
D[RE]
E([code for a scanner])
A--Subset Construction-->B--Kleene's Construction-->D--Thompson's Construction-->A
B--DFA Minimization-->B
A-->E
D--Direct method-->B
```

DFA Minimization有两种算法: Brzozowski, Hopcroft.

## RE to NFA: Thompson Construction

先看正则表达式的结构, 这里就不那么形式化了, 用Haskell的语法写了=_=


<!--{% highlight haskell %}-->
<!--{% endhighlight %}-->

~~~ haskell
data RegExp
    = Symbol Char          -- Basic Character a
    | Concat RegExp RegExp -- Concatenation   ab
    | Union  RegExp RegExp -- Union           a+b
    | Star   RegExp        -- Kleene star     a\*
~~~

- 当`RegExp`是`Symbol a`时

  ```mermaid
  stateDiagram-v2
  	direction LR
  	s0
  	s1
  	[*]-->s0
  	s0-->s1:a
  	s1-->[*]
  ```

- 当`RegExp`是`Concat e1 e2`时

  ```mermaid
  stateDiagram-v2
  	direction LR
  	%% e1-->e2:ε
  	s1-->s3:ε
  	state e1{
  		direction LR
  		[*]-->s0
  		s0-->s1
  	}
  	state e2{
  		direction LR
  		s3-->s4
  		s4-->[*]
  	}
  ```


- 当`RegExp`是`Union e1 e2`时

  ```mermaid
  stateDiagram-v2
  	direction LR
  	[*]-->s0
  	s0-->s1:ε
  	s0-->s3:ε
  	s2-->s5:ε
  	s4-->s5:ε
  	s5-->[*]
  	state e1{
  		direction LR
  			s1-->s2
  	}
  	state e2{
  		direction LR
  			s3-->s4
  	}
  ```


- 当`RegExp`是`Star e`时

  ```mermaid
  stateDiagram-v2
  	direction LR
  	[*]-->s0
  	s0-->s1:ε
  	
  	s2-->s3:ε
  	s3-->[*]
  	state e{
  		direction LR
  		s1-->s2
  		s2-->s1:ε
  	}
  ```


> 做题的时候一定不要图省事, 省略某些步骤; 严格按照这四个pattern来, 会让你避免很多麻烦

## NFA to DFA: 子集构造法

子集构造法有两个重要的函数
  - $\text{Move}(s_i, a)$, 返回从状态$s_i$接收输入$a$能到达的状态集合
  - $\text{FollowEpsilon}(s_i)$, 返回从状态$s_i$接收$\epsilon$能到达的状态集合, 包括$s_i$本身和经过多次空转移到达的状态

用自然语言描述这个算法就是:
  1. 从NFA的起始状态$n_0$构造出DFA的起始状态$d_0$
     - $d_0 = \text{FollowEpsilon}(\{n_0\})$
     - 令$D = \{d_0\}$
  2. 对所有$\alpha\in \Sigma$, 计算$\text{FollowEpsilon}(\text{Move}(d_0, \alpha))$
     - 如果这一步算出了新状态, 将其加入$D$
  3. 遍历$D$, 对每个状态计算$\text{FollowEpsilon}(\text{Move}(d_0, \alpha))$, 直到没有新状态产生为止 
     - 子集构造法也涉及到有趣的不动点问题. 

用伪代码则是:

$$d_0 \leftarrow \text{FollowEpsilon}(\{n_0\}) \newline D \leftarrow \{d_0\} \newline W \leftarrow \{d_0\} \newline \text{while }(W \ne \emptyset) \{ \newline$$


## DFA to Minimal DFA

### Brzozowski’s algorithm

### Hopcroft’s algorithm

## DFA to RE: Kleene's construction


