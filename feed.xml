<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://j0hn50n133.github.io/</id><title>J0HN50N133's Blog</title><subtitle>Just a stupid blog.</subtitle> <updated>2024-03-26T21:17:19+08:00</updated> <author> <name>Johnsonlee</name> <uri>https://j0hn50n133.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://j0hn50n133.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://j0hn50n133.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 Johnsonlee </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Rust Receipe</title><link href="https://j0hn50n133.github.io/posts/rust-receipe/" rel="alternate" type="text/html" title="Rust Receipe" /><published>2024-03-26T16:03:00+08:00</published> <updated>2024-03-26T16:03:00+08:00</updated> <id>https://j0hn50n133.github.io/posts/rust-receipe/</id> <content src="https://j0hn50n133.github.io/posts/rust-receipe/" /> <author> <name>Johnsonlee</name> </author> <category term="Rust" /> <summary> 开启Cargo Bench 截至目前(1.78)必须在nightly环境里使用: rustup override set nightly 在需要使用bench的mod里放置下面两行代码: #![feature(test)] extern crate test; bench代码示例: #[bench] fn bench(b: &amp;amp;mut Bencher){ b.iter(||{ ... }) } 模拟函数重载 Rust没有函数重载，但我们可以通过Trait来模拟 pub trait Foo&amp;lt;Args&amp;gt; { fn invoke(&amp;amp;self, args: Args); } struct FooImpl; impl Foo&amp;lt;i32&amp;gt; for Fo... </summary> </entry> <entry><title>Meltdown攻击</title><link href="https://j0hn50n133.github.io/posts/meltdown/" rel="alternate" type="text/html" title="Meltdown攻击" /><published>2024-03-03T17:13:00+08:00</published> <updated>2024-03-03T17:13:00+08:00</updated> <id>https://j0hn50n133.github.io/posts/meltdown/</id> <content src="https://j0hn50n133.github.io/posts/meltdown/" /> <author> <name>Johnsonlee</name> </author> <category term="security" /> <summary> 今天和群友聊天的时候知道了Meltdown attack/spectre这种奇妙的侧信道攻击手法。 利用这种手法，任意的进程都可以得到物理内存中的任意内容，可以轻易地得到内核中的敏感信息。 什么是侧信道攻击 什么是侧信道攻击？ 侧信道是指你的程序在正常的通信渠道以外，产生了某些其他的特征，而攻击者从这些特 里拿到了你不想暴露的信息。这个“其他的特征”产生的信息通道就是侧信道。举个例子，假设你正在破解一个保险箱的密码，从正常的通信渠道来说你只能暴力破解，逐个尝试，但是当你破解第一位密码时，你发现旋钮到了4会有一些微弱的不一样的响声，那么可以有理由猜测第一位密码是4，这个例子里“旋钮是否发出异响”就是一个侧信道，通过它攻击者得到了保险箱的密码。 Meltdown的攻击原理 CPU运行的时候，不可避免的，总是要从内存中取数据的，而内存相对与CPU很慢，为了避免取数据时CPU空等，CP... </summary> </entry> <entry><title>GreptimeDB Heartbeat机制详解</title><link href="https://j0hn50n133.github.io/posts/greptime-heartbeat/" rel="alternate" type="text/html" title="GreptimeDB Heartbeat机制详解" /><published>2023-12-28T16:14:00+08:00</published> <updated>2023-12-28T16:14:00+08:00</updated> <id>https://j0hn50n133.github.io/posts/greptime-heartbeat/</id> <content src="https://j0hn50n133.github.io/posts/greptime-heartbeat/" /> <author> <name>Johnsonlee</name> </author> <category term="GreptimeDB" /> <summary> 本文将讲解greptimedb内部的heartbeat机制。首先看看官网Developer guide的介绍： Heartbeat Task is used to send heartbeat to the Metasrv. The heartbeat plays a crucial role in the distributed architecture of GreptimeDB and serves as a basic communication channel for distributed coordination. The upstream heartbeat messages contain important information such as the workload of a Region. If the Metasrv has made sche... </summary> </entry> <entry><title>数据库领域会议和期刊合集</title><link href="https://j0hn50n133.github.io/posts/database-conference/" rel="alternate" type="text/html" title="数据库领域会议和期刊合集" /><published>2023-12-28T15:22:00+08:00</published> <updated>2023-12-28T15:22:00+08:00</updated> <id>https://j0hn50n133.github.io/posts/database-conference/</id> <content src="https://j0hn50n133.github.io/posts/database-conference/" /> <author> <name>Johnsonlee</name> </author> <category term="Database Research" /> <summary> 以下是一些数据库相关领域的会议以及期刊 会议 A类会议 VLDB - Very Large Data Bases CIDR - Conference on Innovative Data Systems Research SIGMOD - Special Interest Group on Management of Data ICDE - The International Council for Open and Distance Education OSDI - Operating Systems Design and Implementation FAST - File and Storage Technologies B类会议 EDBT - Extending Database Technology ICDT - The ... </summary> </entry> <entry><title>泛型在Go中的应用</title><link href="https://j0hn50n133.github.io/posts/go-generics/" rel="alternate" type="text/html" title="泛型在Go中的应用" /><published>2022-03-22T20:08:00+08:00</published> <updated>2022-03-22T20:08:00+08:00</updated> <id>https://j0hn50n133.github.io/posts/go-generics/</id> <content src="https://j0hn50n133.github.io/posts/go-generics/" /> <author> <name>Johnsonlee</name> </author> <category term="Go" /> <summary> Go1.18正式发布，从此Go算是正式有了泛型，本文来探讨Go泛型的几种应用场景。 类型安全的函数式接口 在Go语言里，函数是一等公民，这意味着你可以进行一定程度的函数式编程，但是因为Go拉胯的类型系统以及Lambda表达式的缺位，Go做起函数式编程来总是不太舒服，现在有了参数化类型以后map，fold，filter等函数总算是能舒服些了。接下来看看如何利用泛型实现出类型安全的Map， Filter， Foldl，Foldr。 实现 从这几个函数的类型签名入手，然后按语义进行翻译就是了： 这里类型签名采用我偏爱的Haskell的类型签名（同时混合使用了Go的类型），个人认为这种记法的好处在于分离了identifier和type signature，便于一眼看出函数的类型以及进行类型的运算；这种记法里的-&amp;gt;可以理解为一个映射 Map :: (A -&amp;gt;... </summary> </entry> </feed>
