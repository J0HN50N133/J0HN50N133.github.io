<!doctype html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="GreptimeDB Heartbeat机制详解" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="本文将讲解greptimedb内部的heartbeat机制。首先看看官网Developer guide的介绍：" /><meta property="og:description" content="本文将讲解greptimedb内部的heartbeat机制。首先看看官网Developer guide的介绍：" /><link rel="canonical" href="https://j0hn50n133.github.io/posts/greptime-heartbeat/" /><meta property="og:url" content="https://j0hn50n133.github.io/posts/greptime-heartbeat/" /><meta property="og:site_name" content="J0HN50N133’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-12-28T16:14:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="GreptimeDB Heartbeat机制详解" /><meta name="google-site-verification" content="ZB3rlR7kPYyo0sZLZd4_IT93Bz9iKjbfvdUuIKFlv8Q" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-12-28T16:14:00+08:00","datePublished":"2023-12-28T16:14:00+08:00","description":"本文将讲解greptimedb内部的heartbeat机制。首先看看官网Developer guide的介绍：","headline":"GreptimeDB Heartbeat机制详解","mainEntityOfPage":{"@type":"WebPage","@id":"https://j0hn50n133.github.io/posts/greptime-heartbeat/"},"url":"https://j0hn50n133.github.io/posts/greptime-heartbeat/"}</script><title>GreptimeDB Heartbeat机制详解 | J0HN50N133's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="J0HN50N133's Blog"><meta name="application-name" content="J0HN50N133's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"> <img src="https://avatars.githubusercontent.com/u/53596783" width="112" height="112" alt="avatar" onerror="this.style.display='none'"> </a><h1 class="site-title"> <a href="/">J0HN50N133's Blog</a></h1><p class="site-subtitle fst-italic mb-0">Yet another stupid blog.</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>首页</span> </a><li class="nav-item"> <a href="/microblog/" class="nav-link"> <i class="fa-fw fas fa-blog"></i> <span>微·博客</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>关于</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/J0HN50N133" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="javascript:location.href = 'mailto:' + ['0xjohnsonlee','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>GreptimeDB Heartbeat机制详解</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> 文章</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">取消</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>GreptimeDB Heartbeat机制详解</h1><div class="post-meta text-muted"> <span> 发表于 <time data-ts="1703751240" data-df="YYYY/MM/DD" data-bs-toggle="tooltip" data-bs-placement="bottom" > 2023/12/28 </time> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://github.com/j0hn50n133">Johnsonlee</a> </em> </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="3080 字" > <em>17 分钟</em>阅读</span></div></div></header><div class="content"><p><a href="https://raw.githubusercontent.com/J0HN50N133/tuchuang/main/Pasted%20image%2020231215222045.png" class="popup img-link shimmer"><img src="https://raw.githubusercontent.com/J0HN50N133/tuchuang/main/Pasted%20image%2020231215222045.png" alt="" loading="lazy"></a> 本文将讲解<code class="language-plaintext highlighter-rouge">greptimedb</code>内部的heartbeat机制。首先看看官网Developer guide的介绍：</p><blockquote><p>Heartbeat Task is used to send heartbeat to the Metasrv. The heartbeat plays a crucial role in the distributed architecture of GreptimeDB and serves as a basic communication channel for distributed coordination. The upstream heartbeat messages contain important information such as the workload of a Region. If the Metasrv has made scheduling(such as Region migration) decisions, it will send instructions to the Datanode via downstream heartbeat messages.</p></blockquote><h2 id="overview"><span class="me-2">Overview</span><a href="#overview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>可以看到在<code class="language-plaintext highlighter-rouge">greptimedb</code>中<code class="language-plaintext highlighter-rouge">Heartbeat</code>分两个方向<code class="language-plaintext highlighter-rouge">upstream</code>和<code class="language-plaintext highlighter-rouge">downstream</code>，并且<code class="language-plaintext highlighter-rouge">Datanode</code>和<code class="language-plaintext highlighter-rouge">Frontend</code>都会向<code class="language-plaintext highlighter-rouge">Meta Server</code>发送心跳。<code class="language-plaintext highlighter-rouge">upstream</code>是<code class="language-plaintext highlighter-rouge">datanode</code>上报<code class="language-plaintext highlighter-rouge">region</code>信息到<code class="language-plaintext highlighter-rouge">meta srv</code>，<code class="language-plaintext highlighter-rouge">downstream</code>方向是<code class="language-plaintext highlighter-rouge">meta srv</code>主动向<code class="language-plaintext highlighter-rouge">datanode</code>发起调度。</p><h2 id="datanode的heartbeat"><span class="me-2">Datanode的Heartbeat</span><a href="#datanode的heartbeat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>主要逻辑位于：<code class="language-plaintext highlighter-rouge">datanode/src/heartbeat.rs</code>里。核心是<code class="language-plaintext highlighter-rouge">HeartbeatTask</code>。在<code class="language-plaintext highlighter-rouge">Datanode</code>启动的时候，<code class="language-plaintext highlighter-rouge">HeartbeatTask</code>随之<code class="language-plaintext highlighter-rouge">start</code>，并且<code class="language-plaintext highlighter-rouge">Datanode</code>会传入其<code class="language-plaintext highlighter-rouge">region_event_receiver</code>和<code class="language-plaintext highlighter-rouge">leases_notifier</code>给<code class="language-plaintext highlighter-rouge">HeartbeatTask</code>。<code class="language-plaintext highlighter-rouge">region_event_receiver</code>接收<code class="language-plaintext highlighter-rouge">RegionServerEvent</code>，也就是<code class="language-plaintext highlighter-rouge">region</code>的<code class="language-plaintext highlighter-rouge">Registered</code>和<code class="language-plaintext highlighter-rouge">Deregistered</code>两个事件，因为<code class="language-plaintext highlighter-rouge">Heartbeat</code>上报的是<code class="language-plaintext highlighter-rouge">RegionStat</code>，故<code class="language-plaintext highlighter-rouge">Region</code>发生了<code class="language-plaintext highlighter-rouge">Registered</code>和<code class="language-plaintext highlighter-rouge">Deregistered</code>时，自然需要做出对应的逻辑调整。</p><h3 id="heartbeattask的创建"><span class="me-2">HeartbeatTask的创建</span><a href="#heartbeattask的创建" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>逻辑位于<code class="language-plaintext highlighter-rouge">HeartbeatTask::try_new</code>中。 首先是创建了一个<code class="language-plaintext highlighter-rouge">region_alive_keeper</code>。这个东西非常重要，首先看看源码里的文档是怎么说的：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>/// [RegionAliveKeeper] manages all [CountdownTaskHandle]s.
///
/// [RegionAliveKeeper] starts a [CountdownTask] for each region. When the deadline is reached,
/// the status of region be set to "readonly", ensures there is no side-effect in the entity system.
///
/// The deadline is controlled by the meta server. Datanode will send its opened regions info to meta sever
/// via heartbeat. If the meta server decides some region could be resided in this Datanode,
/// it will renew the lease of region, a deadline of [CountdownTask] will be reset.
</pre></table></code></div></div><p>核心意思就是说：<code class="language-plaintext highlighter-rouge">region_alive_keeper</code>为每个<code class="language-plaintext highlighter-rouge">region</code>维护了一个倒计时任务，一旦这个任务被执行，<code class="language-plaintext highlighter-rouge">region</code>就变成<code class="language-plaintext highlighter-rouge">readonly</code>状态（不知道和memtable的frozen有没有关系）。<code class="language-plaintext highlighter-rouge">heartbeat</code>时会上报所有<code class="language-plaintext highlighter-rouge">open</code>的<code class="language-plaintext highlighter-rouge">region</code>的<code class="language-plaintext highlighter-rouge">RegionStat</code>，如果<code class="language-plaintext highlighter-rouge">meta srv</code>认为这个<code class="language-plaintext highlighter-rouge">region</code>能继续存活，就会刷新这个<code class="language-plaintext highlighter-rouge">region</code>的<code class="language-plaintext highlighter-rouge">lease</code>，也就是重置倒计时。<code class="language-plaintext highlighter-rouge">RegionAliveKeeper</code>有一个<code class="language-plaintext highlighter-rouge">epoch</code>，指的是该<code class="language-plaintext highlighter-rouge">RegionAliveKeeper</code>创建的时间，刷新<code class="language-plaintext highlighter-rouge">region</code>的<code class="language-plaintext highlighter-rouge">lease</code>的时候会以这个<code class="language-plaintext highlighter-rouge">epoch</code>为基准进行计算(<code class="language-plaintext highlighter-rouge">RegionAliveKeeper</code>作为<code class="language-plaintext highlighter-rouge">HeartbeatResponseHandler</code>的行为)；发送<code class="language-plaintext highlighter-rouge">HearbeatRequest</code>的时候也以<code class="language-plaintext highlighter-rouge">epoch</code>作为基准，计算当前时间和<code class="language-plaintext highlighter-rouge">epoch</code>的偏移量<code class="language-plaintext highlighter-rouge">duration_since_epoch</code>并放在<code class="language-plaintext highlighter-rouge">Request</code>里上报。 然后是创建一个<code class="language-plaintext highlighter-rouge">resp_handler_executor</code>，这里<code class="language-plaintext highlighter-rouge">resp_handler_executor</code>的核心是一个<code class="language-plaintext highlighter-rouge">Arc&lt;dyn HeartbeatResponseHandler</code>的<code class="language-plaintext highlighter-rouge">vec</code>，包了一层抽象叫<code class="language-plaintext highlighter-rouge">HandlerGroupExecutor</code>，接收到<code class="language-plaintext highlighter-rouge">resp</code>以后就遍历执行这组<code class="language-plaintext highlighter-rouge">HeartbeatResponseHandler</code>。 创建<code class="language-plaintext highlighter-rouge">HeartbeatTask</code>阶段比较trivial的解析<code class="language-plaintext highlighter-rouge">options</code>之类的逻辑就不再赘述了，不过值得注意的是<code class="language-plaintext highlighter-rouge">HeartbeatTask</code>还取了创建任务的时间并记录在<code class="language-plaintext highlighter-rouge">node_epoch</code>字段里。</p><h3 id="heartbeattask的启动"><span class="me-2">HeartbeatTask的启动</span><a href="#heartbeattask的启动" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>创建完以后就进行<code class="language-plaintext highlighter-rouge">HeartbeatTask</code>的启动了。启动的核心逻辑如下： 首先判断一下当前task是否已经启动过了，避免重复启动。 然后取一大堆<code class="language-plaintext highlighter-rouge">interval</code>,<code class="language-plaintext highlighter-rouge">node_id</code>,<code class="language-plaintext highlighter-rouge">node_epoch</code>,<code class="language-plaintext highlighter-rouge">addr</code>,<strong><code class="language-plaintext highlighter-rouge">meta_client</code></strong> 之类的数据,并创建了一个逻辑上可以称为<code class="language-plaintext highlighter-rouge">outgoing</code>的管道。用<code class="language-plaintext highlighter-rouge">outgoing_tx</code>创建了一个<code class="language-plaintext highlighter-rouge">HeartbeatMailbox</code>。用前面获取的数据创建了一个和<code class="language-plaintext highlighter-rouge">meta_srv</code>之间的<code class="language-plaintext highlighter-rouge">heartbeat stream</code>，并且获取一个能通过该<code class="language-plaintext highlighter-rouge">stream</code>发送<code class="language-plaintext highlighter-rouge">Heartbeat</code>的<code class="language-plaintext highlighter-rouge">HeartbeatSender</code>称之为<code class="language-plaintext highlighter-rouge">tx</code>,而创建<code class="language-plaintext highlighter-rouge">stream时做了什么这里按下不表，后面再说。 取得了</code>tx<code class="language-plaintext highlighter-rouge">以后，启动了</code>region_alive_keeper`。 然后创建了一个死循环，循环的逻辑如下：</p><ol><li>判断当前任务是否被关闭了，是就退出<li>否则，<code class="language-plaintext highlighter-rouge">tokio::select</code>三件事：<ol><li>要么从<code class="language-plaintext highlighter-rouge">outgoing</code>这个channel中收到一个<code class="language-plaintext highlighter-rouge">message</code>，把这个<code class="language-plaintext highlighter-rouge">MailboxMessage</code>encode成一个<code class="language-plaintext highlighter-rouge">HeartbeatRequest</code><ol><li>于是有一个这样的数据流<code class="language-plaintext highlighter-rouge">mailbox-&gt;tx-&gt;meta srv</code><li><code class="language-plaintext highlighter-rouge">mailbox</code>的数据来源<ol><li>对<code class="language-plaintext highlighter-rouge">IncomingMessage</code>（也就是<code class="language-plaintext highlighter-rouge">Meta srv</code>对<code class="language-plaintext highlighter-rouge">Datanode</code>发出的<code class="language-plaintext highlighter-rouge">Instruction</code>）对应的响应(<code class="language-plaintext highlighter-rouge">OutgoingMessage</code>=<code class="language-plaintext highlighter-rouge">MessageMeta</code>+<code class="language-plaintext highlighter-rouge">InstructionReply</code>)</ol></ol><li>要么睡够了<code class="language-plaintext highlighter-rouge">interval</code>这么长的时间(第一次进循环时不睡，直接进这个事件)，收集所有<code class="language-plaintext highlighter-rouge">opened_region</code>的<code class="language-plaintext highlighter-rouge">region_stat</code>，构造<code class="language-plaintext highlighter-rouge">HeartbeatRequest</code><li>要么收到了<code class="language-plaintext highlighter-rouge">quit_signal</code>，构造一个dummy heartbeat request，通过后续发送重新建立heartbeat stream。</ol><li>通过<code class="language-plaintext highlighter-rouge">tx</code>(HeartbeatSender)发送上一步构造的<code class="language-plaintext highlighter-rouge">HeartbeatRequst</code>,如果发送出现错误，尝试重新建立<code class="language-plaintext highlighter-rouge">heartbeat stream</code><h3 id="heartbeatstream"><span class="me-2">HeartbeatStream</span><a href="#heartbeatstream" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>上文提到了在启动<code class="language-plaintext highlighter-rouge">HeartbeatTask</code>的时候会通过<code class="language-plaintext highlighter-rouge">create_streams</code>这个函数创建一个<code class="language-plaintext highlighter-rouge">heartbeat stream</code>，通过<code class="language-plaintext highlighter-rouge">heartbeat stream</code>进行<code class="language-plaintext highlighter-rouge">meta srv</code>和<code class="language-plaintext highlighter-rouge">datanode</code>之间心跳包的双向通讯。这个<code class="language-plaintext highlighter-rouge">heartbeat stream</code>的<code class="language-plaintext highlighter-rouge">tx</code>端如何使用上文已经说过了，而<code class="language-plaintext highlighter-rouge">create_streams</code>中则创建了<code class="language-plaintext highlighter-rouge">datanode</code>处理<code class="language-plaintext highlighter-rouge">rx</code>端的死循环，循环就是不断处理来自<code class="language-plaintext highlighter-rouge">meta srv</code>的包，数据包可能是<code class="language-plaintext highlighter-rouge">mailbox incoming message</code>，也可能是普通的<code class="language-plaintext highlighter-rouge">region_lease</code>刷新<code class="language-plaintext highlighter-rouge">message</code>，处理时会对这些数据包做些信息收集工作(打info log或者收集到metric里)，然后就是让前文的<code class="language-plaintext highlighter-rouge">handler_executor</code>处理这些包，最后如果上文的<code class="language-plaintext highlighter-rouge">lease_notifier</code>存在，那就<code class="language-plaintext highlighter-rouge">notify</code>一下。 上面都是正确运行时的循环逻辑，如果从<code class="language-plaintext highlighter-rouge">rx</code>端接收数据包的时候发生错误了，那循环就退出了，并且向<code class="language-plaintext highlighter-rouge">quit_signal</code>中发送信号，表明当前流被断开。 上面是<code class="language-plaintext highlighter-rouge">rx</code>端处理的逻辑。通过前面的综合分析，可以得到下面的图，<code class="language-plaintext highlighter-rouge">datanode</code>和<code class="language-plaintext highlighter-rouge">MetaSrv</code>可以双向通讯，并非简单的C/S模式：</p></ol><p><a href="https://raw.githubusercontent.com/J0HN50N133/tuchuang/main/HeartbeatMailboxOfDatanode.excalidraw.svg" class="popup img-link shimmer"><img src="https://raw.githubusercontent.com/J0HN50N133/tuchuang/main/HeartbeatMailboxOfDatanode.excalidraw.svg" alt="" loading="lazy"></a></p><p>而建立stream的逻辑实际上在<code class="language-plaintext highlighter-rouge">meta_client.heartbeat()</code>中，<code class="language-plaintext highlighter-rouge">meta_client.heartbeat()</code>转到了<code class="language-plaintext highlighter-rouge">heartbeat_client().heartbeat()</code>里，这里可以参考[[MetaClient]]。 <code class="language-plaintext highlighter-rouge">heartbeat_client().hearbeat()</code>第一步是<code class="language-plaintext highlighter-rouge">ask_leader</code>，其流程是获取当前的<code class="language-plaintext highlighter-rouge">leadership_group</code>的所有<code class="language-plaintext highlighter-rouge">peers</code>后<code class="language-plaintext highlighter-rouge">shuffle</code>之，再遍历一趟，向每个<code class="language-plaintext highlighter-rouge">peer</code>发送<code class="language-plaintext highlighter-rouge">AskLeaderRequest</code>，得到<code class="language-plaintext highlighter-rouge">leader</code>以后，向<code class="language-plaintext highlighter-rouge">leadership_group</code>写入<code class="language-plaintext highlighter-rouge">leader</code>信息。 第二步是真正的<code class="language-plaintext highlighter-rouge">inner.heartbeat()</code>，逻辑如下：</p><ol><li>构造一个连接到<code class="language-plaintext highlighter-rouge">leader</code>的<code class="language-plaintext highlighter-rouge">client</code><li>构造用于发送请求的<code class="language-plaintext highlighter-rouge">mpsc::channel::&lt;HeartbeatRequest&gt;(128)</code>(这应该是<code class="language-plaintext highlighter-rouge">tonic</code>这个框架里的某种idiom)<div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nn">mpsc</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HeartbeatRequest</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span>
<span class="n">sender</span><span class="nf">.send</span><span class="p">(</span><span class="n">handshake</span><span class="p">)</span><span class="k">.await</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="p">{</span><span class="o">...</span><span class="p">});</span>
<span class="k">let</span> <span class="n">receiver</span> <span class="o">=</span> <span class="nn">ReceiverStream</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">receiver</span><span class="p">);</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">leader</span>
 <span class="nf">.heartbeat</span><span class="p">(</span><span class="n">receiver</span><span class="p">)</span>
 <span class="k">.await</span>
<span class="c1">// 后续发送请求只要往sender里send就行了，不用关心别的</span>
</pre></table></code></div></div><li>构造包含当前节点<code class="language-plaintext highlighter-rouge">node_id</code>和<code class="language-plaintext highlighter-rouge">role</code>端的<code class="language-plaintext highlighter-rouge">RequestHeader</code><li>构造一个起握手作用的<code class="language-plaintext highlighter-rouge">HeartbeatRequest</code>，并用<code class="language-plaintext highlighter-rouge">sender</code>发送之<li>构造和leader之间的<code class="language-plaintext highlighter-rouge">stream</code><li>获取上面的请求响应，错误了就处理错误<li>包装上面管道的<code class="language-plaintext highlighter-rouge">sender</code>为请求<code class="language-plaintext highlighter-rouge">sender</code>，包装<code class="language-plaintext highlighter-rouge">stream</code>为<code class="language-plaintext highlighter-rouge">receiver</code></ol><h2 id="meta-server对heartbeatrequest的处理"><span class="me-2">Meta Server对HeartbeatRequest的处理</span><a href="#meta-server对heartbeatrequest的处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="纵览逻辑"><span class="me-2">纵览逻辑</span><a href="#纵览逻辑" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>首先找到最关键的<code class="language-plaintext highlighter-rouge">trait</code>,<code class="language-plaintext highlighter-rouge">HeartbeatHandler</code>。</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nd">#[async_trait::async_trait]</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">HeartbeatHandler</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_acceptable</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">role</span><span class="p">:</span> <span class="n">Role</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">type_name</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">any</span><span class="p">::</span><span class="nn">type_name</span><span class="p">::</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="c1">// short name</span>
        <span class="n">type_name</span><span class="nf">.split</span><span class="p">(</span><span class="s">"::"</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">async</span> <span class="k">fn</span> <span class="nf">handle</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">req</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HeartbeatRequest</span><span class="p">,</span>
        <span class="n">ctx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Context</span><span class="p">,</span>
        <span class="n">acc</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">HeartbeatAccumulator</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">HandleControl</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>看到这里就能猜到大概的结构就是有一个总的<code class="language-plaintext highlighter-rouge">handler</code>，然后根据不同<code class="language-plaintext highlighter-rouge">Heartbeat</code>的类型将其分发给具体的<code class="language-plaintext highlighter-rouge">handler</code>（策略模式） 。 总的<code class="language-plaintext highlighter-rouge">handler</code>在<code class="language-plaintext highlighter-rouge">impl heartbeat_server::Heartbeat for MetaSrv</code>里，<code class="language-plaintext highlighter-rouge">heartbeat_server::Heartbeta</code>这个<code class="language-plaintext highlighter-rouge">trait</code>定义核心逻辑非常简单：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">trait</span> <span class="n">Heartbeat</span> <span class="p">{</span>
	<span class="k">type</span> <span class="n">HeartbeatStream</span><span class="p">;</span>
	<span class="k">fn</span> <span class="nf">heartbeat</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="nn">tonic</span><span class="p">::</span><span class="n">Request</span><span class="o">&lt;</span><span class="nn">tonic</span><span class="p">::</span><span class="n">Streaming</span><span class="o">&lt;...&gt;&gt;</span><span class="p">)</span><span class="k">-&gt;</span><span class="o">...</span><span class="p">;</span>
	<span class="k">fn</span> <span class="nf">ask_leader</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">request</span><span class="p">:</span> <span class="nn">tonic</span><span class="p">::</span><span class="n">Request</span><span class="o">&lt;</span><span class="n">AskLeaderRequest</span><span class="o">&gt;</span><span class="p">)</span><span class="k">-&gt;</span><span class="o">...</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">MetaSrv</code>的<code class="language-plaintext highlighter-rouge">heartbeat</code>也非常简单，核心是一个循环，不断得从<code class="language-plaintext highlighter-rouge">stream</code>里取出<code class="language-plaintext highlighter-rouge">request</code>，进行以下操作：</p><ol><li>解析<code class="language-plaintext highlighter-rouge">request</code>，首先<code class="language-plaintext highlighter-rouge">match</code>看看是不是一个合法的<code class="language-plaintext highlighter-rouge">request</code>，不然进错误处理(<code class="language-plaintext highlighter-rouge">Err</code>分支)<li>取出<code class="language-plaintext highlighter-rouge">header</code>，没有<code class="language-plaintext highlighter-rouge">header</code>就报错<li>如果<code class="language-plaintext highlighter-rouge">pusher_key</code>是<code class="language-plaintext highlighter-rouge">None</code><ol><li>取出<code class="language-plaintext highlighter-rouge">node_id</code>，注意，<code class="language-plaintext highlighter-rouge">datanode</code>和<code class="language-plaintext highlighter-rouge">frontend</code>的<code class="language-plaintext highlighter-rouge">heartbeat</code>都是走这个处理函数的，<code class="language-plaintext highlighter-rouge">datanode</code>的<code class="language-plaintext highlighter-rouge">node_id</code>是由<code class="language-plaintext highlighter-rouge">datanode</code>传递过来的<code class="language-plaintext highlighter-rouge">member_id</code>，虽然<code class="language-plaintext highlighter-rouge">datanode</code>传过来的<code class="language-plaintext highlighter-rouge">id</code>=<code class="language-plaintext highlighter-rouge">(cluster_id, member_id)</code>，但这里只用了<code class="language-plaintext highlighter-rouge">member_id</code>。而<code class="language-plaintext highlighter-rouge">frontend</code>则是一个<code class="language-plaintext highlighter-rouge">metasrv</code>内部的自增<code class="language-plaintext highlighter-rouge">AtomicU64</code><li>取出<code class="language-plaintext highlighter-rouge">role</code>，也就是请求发送方到底是<code class="language-plaintext highlighter-rouge">datanode</code>还是<code class="language-plaintext highlighter-rouge">frontend</code><li><code class="language-plaintext highlighter-rouge">node_id</code>和<code class="language-plaintext highlighter-rouge">role</code>拼成key，然后向<code class="language-plaintext highlighter-rouge">handle_group</code>里用这个<code class="language-plaintext highlighter-rouge">key</code>注册一个返回请求的<code class="language-plaintext highlighter-rouge">pusher</code>，<code class="language-plaintext highlighter-rouge">handle_group</code>里有一个从<code class="language-plaintext highlighter-rouge">key</code>到<code class="language-plaintext highlighter-rouge">pusher</code>的<code class="language-plaintext highlighter-rouge">map</code>，<code class="language-plaintext highlighter-rouge">pusher</code>用于主动向下游发送信息(<code class="language-plaintext highlighter-rouge">MailboxMessage</code>)，所以可以猜测，发送<code class="language-plaintext highlighter-rouge">MailboxMessage</code>的时候，收信方是以<code class="language-plaintext highlighter-rouge">key</code>来标识的，也就是<code class="language-plaintext highlighter-rouge">HeartbeatMailbox::send</code>里的<code class="language-plaintext highlighter-rouge">pusher_id</code>。<li>将<code class="language-plaintext highlighter-rouge">pusher_key</code>设为<code class="language-plaintext highlighter-rouge">Some(key)</code>，这里<code class="language-plaintext highlighter-rouge">pusher_key</code>不为<code class="language-plaintext highlighter-rouge">None</code>以后就不用再进这个分支，因为<code class="language-plaintext highlighter-rouge">heartbeat</code>时<code class="language-plaintext highlighter-rouge">Client</code>和<code class="language-plaintext highlighter-rouge">Server</code>之间是长连接的<code class="language-plaintext highlighter-rouge">Stream</code>，后面<code class="language-plaintext highlighter-rouge">Client</code>的key也不会变化，第一次<code class="language-plaintext highlighter-rouge">handshake</code>完了以后，就不需要重新构建链接，也就不需要再注册<code class="language-plaintext highlighter-rouge">key</code>及其对应的<code class="language-plaintext highlighter-rouge">Pusher</code>。(<code class="language-plaintext highlighter-rouge">Frontend</code>因为是无状态的，猜测其<code class="language-plaintext highlighter-rouge">node_id</code>会由第一次<code class="language-plaintext highlighter-rouge">handshake</code>从<code class="language-plaintext highlighter-rouge">MetaSrv</code>处分配后在<code class="language-plaintext highlighter-rouge">Response</code>里获得)。 于是整体数据的流动可以看成这样 <a href="https://raw.githubusercontent.com/J0HN50N133/tuchuang/main/HeartbeatDataflow.svg" class="popup img-link shimmer"><img src="https://raw.githubusercontent.com/J0HN50N133/tuchuang/main/HeartbeatDataflow.svg" alt="" loading="lazy"></a></ol><li>使用HandlerGroup去handle这个request，并得到result<ol><li>逻辑上<code class="language-plaintext highlighter-rouge">HandlerGroup</code>是一个<code class="language-plaintext highlighter-rouge">HeartbeatHandler</code>的<code class="language-plaintext highlighter-rouge">Vec</code>，不过有点小细节的是，实际用的是<code class="language-plaintext highlighter-rouge">NameCachedHandler</code>这个包装，其作用是缓存了<code class="language-plaintext highlighter-rouge">HeartbeatHandler.name()</code>的结果，避免每次都对这个常量去求值(这里<code class="language-plaintext highlighter-rouge">name</code>等于实际的struct type name)<li><code class="language-plaintext highlighter-rouge">HandlerGroup::handle</code>遍历所有<code class="language-plaintext highlighter-rouge">handler</code>，一边遍历一边把中间结果存到<code class="language-plaintext highlighter-rouge">HeartbeatAccumulator</code>中，每个<code class="language-plaintext highlighter-rouge">handler</code>返回<code class="language-plaintext highlighter-rouge">Continue</code>或者<code class="language-plaintext highlighter-rouge">Done</code>，返回<code class="language-plaintext highlighter-rouge">Done</code>说明这个请求已经处理完了，直接跳出循环，然后把<code class="language-plaintext highlighter-rouge">accmulator</code>的内容提取并返回<li><code class="language-plaintext highlighter-rouge">HandlerGroup</code>里还有<code class="language-plaintext highlighter-rouge">pushers</code></ol><li>根据result判断当前stream连接的还是不是leader,如果已经不是leader了，主动断开当前的stream<ol><li>断开stream的时候将第3步注册的pusher给<code class="language-plaintext highlighter-rouge">unregister</code>掉</ol></ol><h3 id="每个handler的逻辑"><span class="me-2">每个handler的逻辑</span><a href="#每个handler的逻辑" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="collectstatshandler"><span class="me-2">CollectStatsHandler</span><a href="#collectstatshandler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>职责：负责收集<code class="language-plaintext highlighter-rouge">HeartbeatRequest</code>中的<code class="language-plaintext highlighter-rouge">stat</code>到<code class="language-plaintext highlighter-rouge">accumulator.stat</code>中。<li>接受请求来源：只接受来自<code class="language-plaintext highlighter-rouge">datanode</code>的<code class="language-plaintext highlighter-rouge">Heartbeat</code>，并且不处理<code class="language-plaintext highlighter-rouge">MailboxMessage</code>（<code class="language-plaintext highlighter-rouge">MailboxMessage</code>不会有stat）。<li>实现逻辑：<ul><li>如果请求是<code class="language-plaintext highlighter-rouge">MailboxMessage</code>，直接返回<code class="language-plaintext highlighter-rouge">Continue</code>。<li>尝试从<code class="language-plaintext highlighter-rouge">Request</code>中提取出<code class="language-plaintext highlighter-rouge">Stat</code>，成功提取了就将<code class="language-plaintext highlighter-rouge">stat</code>插入<code class="language-plaintext highlighter-rouge">accumulator.stat</code>，失败了打一条警告信息<li>返回<code class="language-plaintext highlighter-rouge">Continue</code></ul></ul><h4 id="checkleaderhandler"><span class="me-2">CheckLeaderHandler</span><a href="#checkleaderhandler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>职责：判断当前<code class="language-plaintext highlighter-rouge">MetaSrv</code>是否仍是<code class="language-plaintext highlighter-rouge">Leader</code><li>接受请求来源：只接受来自<code class="language-plaintext highlighter-rouge">datanode</code>的<code class="language-plaintext highlighter-rouge">Heartbeat</code>。<li>实现逻辑：<ul><li>如果当前<code class="language-plaintext highlighter-rouge">context</code>里没有<code class="language-plaintext highlighter-rouge">election</code>模块(没有可能是单节点模式)，直接返回<code class="language-plaintext highlighter-rouge">Continue</code><li>用上面获取到的<code class="language-plaintext highlighter-rouge">election</code>模块判断当前<code class="language-plaintext highlighter-rouge">metasrv</code>是否是<code class="language-plaintext highlighter-rouge">leader</code>，是<code class="language-plaintext highlighter-rouge">leader</code>可以直接返回<code class="language-plaintext highlighter-rouge">Continue</code><li>不是<code class="language-plaintext highlighter-rouge">leader</code>就在<code class="language-plaintext highlighter-rouge">Response</code>的<code class="language-plaintext highlighter-rouge">header</code>里写入错误信息<code class="language-plaintext highlighter-rouge">Error::is_not_leader()</code><li>返回<code class="language-plaintext highlighter-rouge">Done</code>，因为当前节点不是<code class="language-plaintext highlighter-rouge">leader</code>的话，后面的<code class="language-plaintext highlighter-rouge">handler</code>也没有必要再继续做了</ul></ul><h4 id="keepleasehandler"><span class="me-2">KeepLeaseHandler</span><a href="#keepleasehandler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>职责：维护每个节点上次续租的时间，也就是<code class="language-plaintext highlighter-rouge">node</code>到<code class="language-plaintext highlighter-rouge">lease</code>的<code class="language-plaintext highlighter-rouge">KV</code>对<li>接受请求来源：<code class="language-plaintext highlighter-rouge">datanode</code><li>实现逻辑：<ul><li>取出<code class="language-plaintext highlighter-rouge">Request</code>的<code class="language-plaintext highlighter-rouge">header</code>和<code class="language-plaintext highlighter-rouge">peer</code>(请求来自谁)，没有直接返回<li>拼出<code class="language-plaintext highlighter-rouge">lease_key</code>:<code class="language-plaintext highlighter-rouge">(cluster_id,node_id)</code><li>拼出<code class="language-plaintext highlighter-rouge">lease_value</code>：当前的时间戳（语义为上次活动时间）和<code class="language-plaintext highlighter-rouge">peer</code>的地址<li>把上面的<code class="language-plaintext highlighter-rouge">key</code>和<code class="language-plaintext highlighter-rouge">value</code>转成字节数组(<code class="language-plaintext highlighter-rouge">Vec&lt;u8&gt;</code>)，写入存储元数据的<code class="language-plaintext highlighter-rouge">KV</code>库。这里写入的是<code class="language-plaintext highlighter-rouge">ResettableKvBackend</code>，没有进行持久化<li>返回<code class="language-plaintext highlighter-rouge">Continue</code></ul></ul><h4 id="regionleasehandler"><span class="me-2">RegionLeaseHandler</span><a href="#regionleasehandler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>核心逻辑<ul><li>取出<code class="language-plaintext highlighter-rouge">stat</code>的所有<code class="language-plaintext highlighter-rouge">regions</code>及其所在的<code class="language-plaintext highlighter-rouge">cluster_id</code>和<code class="language-plaintext highlighter-rouge">datanode_id</code><ul><li>刷新每个<code class="language-plaintext highlighter-rouge">cluster_id</code>,<code class="language-plaintext highlighter-rouge">datanode_id</code>和<code class="language-plaintext highlighter-rouge">region_id</code>构成的三元组对应的<code class="language-plaintext highlighter-rouge">lease</code>；返回不存在的<code class="language-plaintext highlighter-rouge">region</code>以及成功刷新的<code class="language-plaintext highlighter-rouge">region</code>有哪些(注意<code class="language-plaintext highlighter-rouge">region_id</code>和<code class="language-plaintext highlighter-rouge">role</code>才构成一个完整的<code class="language-plaintext highlighter-rouge">region</code>描述符)</ul><li>成功刷新<code class="language-plaintext highlighter-rouge">lease</code>的<code class="language-plaintext highlighter-rouge">regions</code>集合转成<code class="language-plaintext highlighter-rouge">GrantedRegion</code>的<code class="language-plaintext highlighter-rouge">vector</code></ul></ul><h4 id="persiststatshandler"><span class="me-2">PersistStatsHandler</span><a href="#persiststatshandler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>接受请求来源：<code class="language-plaintext highlighter-rouge">datanode</code><li>具体实现逻辑：<ul><li>取出<code class="language-plaintext highlighter-rouge">accumulator</code>里的<code class="language-plaintext highlighter-rouge">stat</code>，没有就直接返回<li>取<code class="language-plaintext highlighter-rouge">stat</code>的<code class="language-plaintext highlighter-rouge">stat_key</code>(同样是<code class="language-plaintext highlighter-rouge">(cluster_id, node_id)</code>)<ul><li><code class="language-plaintext highlighter-rouge">PersistStatsHandler</code>内有一个<code class="language-plaintext highlighter-rouge">StatKey-&gt;EpochStats</code>的<code class="language-plaintext highlighter-rouge">DashMap</code>，称为<code class="language-plaintext highlighter-rouge">stats_cache</code><li><code class="language-plaintext highlighter-rouge">EpochStats</code>=Optional Epoch + Vector of <code class="language-plaintext highlighter-rouge">Stat</code></ul><li>取出<code class="language-plaintext highlighter-rouge">stat_cache</code>里记录的<code class="language-plaintext highlighter-rouge">epoch_stat</code>，没有就插个默认的<li>判断是否需要刷新<code class="language-plaintext highlighter-rouge">epoch</code><ul><li>如果<code class="language-plaintext highlighter-rouge">epoch_stat</code>里存在<code class="language-plaintext highlighter-rouge">epoch</code>,如果<code class="language-plaintext highlighter-rouge">current_stat</code>传过来的<code class="language-plaintext highlighter-rouge">node_epoch</code>更大就更新，并且清空之前记录的所有<code class="language-plaintext highlighter-rouge">stat</code>(因为这意味着<code class="language-plaintext highlighter-rouge">node</code>可能重新deploy了，<code class="language-plaintext highlighter-rouge">node_epoch</code>发生了改变);<code class="language-plaintext highlighter-rouge">node_epoch</code>更小就是接收到了过期的<code class="language-plaintext highlighter-rouge">heartbeat</code>，那么忽略，并警告；如果<code class="language-plaintext highlighter-rouge">node_epoch</code>和<code class="language-plaintext highlighter-rouge">epoch</code>相等，则是正常的<li>如果<code class="language-plaintext highlighter-rouge">epoch_stat</code>里不存在<code class="language-plaintext highlighter-rouge">epoch</code>，毫无疑问，直接设置<code class="language-plaintext highlighter-rouge">current_stat</code>里传过来的<code class="language-plaintext highlighter-rouge">node_epoch</code>作为<code class="language-plaintext highlighter-rouge">epoch</code></ul><li>向<code class="language-plaintext highlighter-rouge">epoch_stat</code>中插入<code class="language-plaintext highlighter-rouge">current_stat</code><li>如果之前判断不需要刷新<code class="language-plaintext highlighter-rouge">epoch</code>，那么只需要判断<code class="language-plaintext highlighter-rouge">epoch_stats</code>里记录的<code class="language-plaintext highlighter-rouge">stat</code>数量是否小于阈值<code class="language-plaintext highlighter-rouge">MAX_CACHED_STATS_PER_KEY</code>，小于就返回<code class="language-plaintext highlighter-rouge">Continue</code><li>否则，需要持久化<code class="language-plaintext highlighter-rouge">epoch_stats</code>了，把<code class="language-plaintext highlighter-rouge">epoch_stats</code>的所有<code class="language-plaintext highlighter-rouge">stats</code>拎出来(<code class="language-plaintext highlighter-rouge">drain_all</code>)然后写到<code class="language-plaintext highlighter-rouge">in_memory</code>的<code class="language-plaintext highlighter-rouge">KV</code>里</ul><li>结论：<ul><li><code class="language-plaintext highlighter-rouge">stats</code>做了一个多阶段的<code class="language-plaintext highlighter-rouge">Cache</code>，首先在<code class="language-plaintext highlighter-rouge">Hadler</code>里按<code class="language-plaintext highlighter-rouge">(cluster_id,node_id)</code>作为<code class="language-plaintext highlighter-rouge">key</code>，维护了一个记录对应的<code class="language-plaintext highlighter-rouge">stats</code>的局部<code class="language-plaintext highlighter-rouge">cache</code>，用<code class="language-plaintext highlighter-rouge">epoch</code>来判断当前的<code class="language-plaintext highlighter-rouge">stats</code>是否仍然合法；写满了就写到全局的<code class="language-plaintext highlighter-rouge">in_memory</code>键值存储里，缓解全局<code class="language-plaintext highlighter-rouge">in_memory</code>存储的压力</ul></ul><h2 id="datanode对heartbeatresponse的处理"><span class="me-2">Datanode对HeartbeatResponse的处理</span><a href="#datanode对heartbeatresponse的处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/greptimedb/">GreptimeDB</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/wip/" class="post-tag no-text-decoration" >WIP 🚧</a> <a href="/tags/greptimedb/" class="post-tag no-text-decoration" >GreptimeDB</a> <a href="/tags/heartbeat/" class="post-tag no-text-decoration" >Heartbeat</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted me-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=GreptimeDB%20Heartbeat%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%20-%20J0HN50N133's%20Blog&url=https%3A%2F%2Fj0hn50n133.github.io%2Fposts%2Fgreptime-heartbeat%2F" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter" > <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=GreptimeDB%20Heartbeat%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%20-%20J0HN50N133's%20Blog&u=https%3A%2F%2Fj0hn50n133.github.io%2Fposts%2Fgreptime-heartbeat%2F" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook" > <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fj0hn50n133.github.io%2Fposts%2Fgreptime-heartbeat%2F&text=GreptimeDB%20Heartbeat%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%20-%20J0HN50N133's%20Blog" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram" > <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="分享链接" data-title-succeed="链接已复制！" > <i class="fa-fw fas fa-link pe-none"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section><h2 class="panel-heading">热门标签</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/error-handling/">Error Handling</a> <a class="post-tag btn btn-outline-primary" href="/tags/finite-state-automata/">Finite State Automata</a> <a class="post-tag btn btn-outline-primary" href="/tags/generics/">Generics</a> <a class="post-tag btn btn-outline-primary" href="/tags/greptimedb/">GreptimeDB</a> <a class="post-tag btn btn-outline-primary" href="/tags/heartbeat/">Heartbeat</a> <a class="post-tag btn btn-outline-primary" href="/tags/lisp/">lisp</a> <a class="post-tag btn btn-outline-primary" href="/tags/python/">python</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">Rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/wip/">WIP 🚧</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA/">自动机理论</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">文章内容</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/database-conference/" class="btn btn-outline-primary" aria-label="上一篇" ><p>数据库领域会议和期刊合集</p></a> <a href="/posts/meltdown/" class="btn btn-outline-primary" aria-label="下一篇" ><p>Meltdown攻击</p></a></nav><script src="https://utteranc.es/client.js" repo="J0HN50N133/J0HN50N133.github.io" issue-term="pathname" crossorigin="anonymous" async ></script> <script type="text/javascript"> (function () { const origin = 'https://utteranc.es'; const iframe = 'iframe.utterances-frame'; const lightTheme = 'github-light'; const darkTheme = 'github-dark'; let initTheme = lightTheme; const html = document.documentElement; if ( (html.hasAttribute('data-mode') && html.getAttribute('data-mode') === 'dark') || (!html.hasAttribute('data-mode') && window.matchMedia('(prefers-color-scheme: dark)').matches) ) { initTheme = darkTheme; } addEventListener('message', (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme; } else { return; } const message = { type: 'set-theme', theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); })(); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p> © <time>2024</time> <a href="https://github.com/j0hn50n133">Johnsonlee</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。" >保留部分权利。</span></p><p>本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">热门标签</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/error-handling/">Error Handling</a> <a class="post-tag btn btn-outline-primary" href="/tags/finite-state-automata/">Finite State Automata</a> <a class="post-tag btn btn-outline-primary" href="/tags/generics/">Generics</a> <a class="post-tag btn btn-outline-primary" href="/tags/greptimedb/">GreptimeDB</a> <a class="post-tag btn btn-outline-primary" href="/tags/heartbeat/">Heartbeat</a> <a class="post-tag btn btn-outline-primary" href="/tags/lisp/">lisp</a> <a class="post-tag btn btn-outline-primary" href="/tags/python/">python</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">Rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/wip/">WIP 🚧</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA/">自动机理论</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/zh.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/unregister.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5"></p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
